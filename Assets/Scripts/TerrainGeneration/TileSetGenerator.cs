using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;


[System.Serializable]
public struct Tile
{
    public int weight;
    public GridTile tile;
}

public class TileSetGenerator : MonoBehaviour
{
    [Header("Terrain building variables")]
    public int numCol;
    public int numRow;
    public int maxSteps;
    public bool terrainGenerated = false;
    public Vector3 tileSize;
    public List<Tile> tileSet;
    public NavMeshSurface surface;
    public Transform predefinedPath;
    [HideInInspector] public Variable[,] grid;

    // Variables used to instantiate the Tiles
    Vector3 originalPos;
    Vector3 currentPos;
    bool gridCleared = true;

    // Variables used to handle with a predefined path inside the grid
    bool preDefinedPath = false;
    int[,] predefinedPathCoor;

    /// <summary>
    /// Initialization method whcih prepare all the variables needed
    /// </summary>
    private void Initialize()
    {
        originalPos = transform.position;
        currentPos = transform.position;
        grid = new Variable[numRow, numCol];

        for ( int i = 0; i < grid.GetLength(0); i++)
        {
            for (int j = 0; j < grid.GetLength(1); j++)
            {
                grid[i, j] = ScriptableObject.CreateInstance<Variable>();
                grid[i, j].SetVariable(tileSet.Count);
                grid[i, j].CalculateEntropy(tileSet);
            }
        }


        if (transform.childCount > 0 && predefinedPath.gameObject.activeSelf)
        {
            preDefinedPath = true;
            predefinedPathCoor = new int[predefinedPath.childCount, 2];
            for (int i = 0; i < predefinedPath.childCount; i++)
            {
                int[] coor = { Mathf.FloorToInt(predefinedPath.GetChild(i).position.z), 
                        Mathf.FloorToInt(predefinedPath.GetChild(i).position.x) };
                predefinedPathCoor[i, 0] = coor[0];
                predefinedPathCoor[i, 1] = coor[1];
                int choosenTile = -1;

                for (int k = 0; k < tileSet.Count; k++)
                {
                    if (predefinedPath.GetChild(i).name.StartsWith(tileSet[k].tile.transform.name))
                        choosenTile = k;
                }

                for (int j = 0; j < grid[coor[0], coor[1]].domain.Length; j++)
                {
                    if (j != choosenTile)
                        grid[coor[0], coor[1]].domain[j] = false;
                }

                grid[coor[0], coor[1]].visited[choosenTile]++;
                grid[coor[0], coor[1]].domainCount = 1;
                grid[coor[0], coor[1]].tileChosen = tileSet[choosenTile].tile;
                grid[coor[0], coor[1]].CalculateEntropy(tileSet);
                grid[coor[0], coor[1]].tileReference = predefinedPath.GetChild(i).gameObject;
            }
        }
        else
        {
            preDefinedPath = false;
        }
    }

    /// <summary>
    /// Clear the grid
    /// </summary>
    public void ClearTiles()
    {
        if (!gridCleared)
        {
            terrainGenerated = false;
            gridCleared = true;
            currentPos = originalPos;

            var count = transform.childCount;
            int i = 0;

            while (i < count && i < transform.childCount)
            {
                if(transform.GetChild(i).name != "PredefinedPath")
                {
                    DestroyImmediate(transform.GetChild(i).gameObject, true);
                    count--;
                }
                else
                    i++;
            }

            grid = null;
        }
        else
        {
            Debug.Log("Grid has already been cleared, try to generate a new landscape.");
        }
    }

    /// <summary>
    /// Grid Generation method
    /// </summary>
    public void Generate()
    {
        if (gridCleared)
        {
            terrainGenerated = true;
            gridCleared = false;
            Initialize(); // Initialize the grid to base values

            // If the predefined path is active, propagate the constraint generated by this tiles
            if (preDefinedPath)
            {
                for(int index = 0; index < predefinedPathCoor.GetLength(0); index++)
                {
                    if (predefinedPathCoor[index, 1] > 0)
                        ConstraintPropagation(predefinedPathCoor[index, 0], predefinedPathCoor[index, 1] - 1, 3,
                         grid[predefinedPathCoor[index, 0], predefinedPathCoor[index, 1]], 0);
                    if (predefinedPathCoor[index, 1] < (numCol - 1))
                        ConstraintPropagation(predefinedPathCoor[index, 0], predefinedPathCoor[index, 1] + 1, 1, 
                        grid[predefinedPathCoor[index, 0], predefinedPathCoor[index, 1]], 0);
                    if (predefinedPathCoor[index, 0] > 0)
                        ConstraintPropagation(predefinedPathCoor[index, 0] - 1, predefinedPathCoor[index, 1], 2, 
                        grid[predefinedPathCoor[index, 0], predefinedPathCoor[index, 1]], 0);
                    if (predefinedPathCoor[index, 0] < (numRow - 1))
                        ConstraintPropagation(predefinedPathCoor[index, 0] + 1, predefinedPathCoor[index, 1], 0, 
                        grid[predefinedPathCoor[index, 0], predefinedPathCoor[index, 1]], 0);
                }

                int[] nextCel = SearchNextGridCell();
                if (nextCel[0] != 1 && nextCel[1] != 0)
                    TileElection(nextCel[0], nextCel[1]); // Start  with the terrain generation
            }
            else
            {
                var firstCell = SearchNextGridCell();
                TileElection(firstCell[0], firstCell[1]); // Start  with the terrain generation
            }

            if(surface != null)
                surface.BuildNavMesh();
        }
        else
        {
            Debug.Log("You need to clear the grid to generate a new landscape.");
        }
    }

    /// <summary>
    /// Find the next Grid that is going to be analised
    /// </summary>
    /// <returns></returns>
    public int[] SearchNextGridCell()
    {
        float finalEntropy = Mathf.Infinity;
        int nextCol = -1;
        int nextRow = -1;

        for (int i = 0; i < grid.GetLength(0); i++)
        {
            for (int j = 0; j < grid.GetLength(1); j++)
            {
                if (grid[i, j].tileChosen == null && grid[i, j].domainCount == 1)
                {
                    int[] nextGridCell = new int[2] { i, j };
                    return nextGridCell;
                }
                else if (grid[i, j].domainCount > 1)
                {
                    var entropy = grid[i, j].entropy;
                    if (entropy < finalEntropy)
                    {
                        finalEntropy = entropy;
                        nextRow = i;
                        nextCol = j;
                    }
                }
            }
        }

        return new int[2] { nextRow, nextCol };
    }

    /// <summary>
    /// Instantiate the tile in a certain grid position
    /// </summary>
    /// <param name="rowIndex">Index that represent the current row of the grid</param>
    /// <param name="colIndex">Index that represent the current column of the grid</param>
    /// <param name="chosenIndex">Index that represent the position of the tile in the domain</param>
    private void InstantiateTile(int rowIndex, int colIndex, int chosenIndex)
    {
        currentPos = new Vector3(transform.position.x + colIndex * tileSize.x, transform.position.y, transform.position.z + rowIndex * tileSize.z);
        grid[rowIndex, colIndex].SetTile(tileSet[chosenIndex].tile, chosenIndex, currentPos, transform);
    }

    /// <summary>
    /// Tile setting when the constraint propagation has ended
    /// </summary>
    /// <param name="rowIndex">Row of the matrix</param>
    /// <param name="colIndex">Col of the matrix</param>
    private void TileElection(int rowIndex, int colIndex)
    {
        // Select the only tile available in the domain of the cell if there is only one
        // if not it makes a random election bearing in mind the weights of the tiles
        int chosenIndex = -1;
        if (grid[rowIndex, colIndex].tileChosen == null)
        {
            if (grid[rowIndex, colIndex].domainCount == 1)
            {
                for (int i = 0; i < grid[rowIndex, colIndex].domain.Length; i++)
                {
                    if (grid[rowIndex, colIndex].domain[i])
                    {
                        chosenIndex = i;
                        break;
                    }
                }
            }
            else if (grid[rowIndex, colIndex].domainCount > 1)
            {
                Tile[] availableTiles = new Tile[grid[rowIndex, colIndex].domainCount];
                int j = 0;
                for (int i = 0; i < grid[rowIndex, colIndex].domain.Length; i++)
                {
                    if (grid[rowIndex, colIndex].domain[i] && j < availableTiles.Length)
                    {
                        availableTiles[j] = tileSet[i];
                        j++;
                    }
                }
                chosenIndex = weightedRandom(availableTiles);
            }

            InstantiateTile(rowIndex, colIndex, chosenIndex);
        }

        // Propagates the constraints bearing in mind the current tile
        if(colIndex > 0)
            ConstraintPropagation(rowIndex, colIndex -1, 3, grid[rowIndex, colIndex], 0);
        if(colIndex < (numCol - 1))
            ConstraintPropagation(rowIndex, colIndex + 1, 1, grid[rowIndex, colIndex], 0);
        if(rowIndex > 0)
            ConstraintPropagation(rowIndex - 1, colIndex, 2, grid[rowIndex, colIndex], 0);
        if(rowIndex < (numRow - 1))
            ConstraintPropagation(rowIndex + 1, colIndex, 0, grid[rowIndex, colIndex], 0);

        // Search if any cel has one tile in its domain
        // If can't find any, then choose the one with minimal entropy
        int[] nextGridCell = SearchNextGridCell();

        if(nextGridCell[0] != -1 && nextGridCell[1] != -1)
            TileElection(nextGridCell[0], nextGridCell[1]);
    }

    /// <summary>
    /// Propagation of the constraint from the current tile to the four directions
    /// </summary>
    /// <param name="rowIndex">Row of the matrix</param>
    /// <param name="colIndex">Col of the matrix</param>
    /// <param name="direction">Last cell propagation direction</param>
    /// <param name="lastCell">Last cell of the grid</param>
    /// <param name="step">Step limitation</param>
    private void ConstraintPropagation(int rowIndex, int colIndex, int direction, Variable lastCell, int step)
    {
        if (grid[rowIndex, colIndex].domainCount == 1 || step >= maxSteps || rowIndex < 0 || colIndex < 0 || rowIndex >= numRow || colIndex >= numCol)
            return;

        step++;
        if (lastCell.domainCount == 1)
        {
            for (int i = 0; i < grid[rowIndex, colIndex].domain.Length; i++)
            {
                if (grid[rowIndex, colIndex].domain[i] && grid[rowIndex, colIndex].domainCount > 1)
                {
                    // If the current tile don't respect the last cell constraints
                    if ((direction == 0 && tileSet[i].tile.sideIndex[2] != lastCell.tileChosen.sideIndex[direction])
                        || (direction == 1 && tileSet[i].tile.sideIndex[3] != lastCell.tileChosen.sideIndex[direction])
                        || (direction == 2 && tileSet[i].tile.sideIndex[0] != lastCell.tileChosen.sideIndex[direction])
                        || (direction == 3 && tileSet[i].tile.sideIndex[1] != lastCell.tileChosen.sideIndex[direction]))
                    {
                        grid[rowIndex, colIndex].domain[i] = false;
                        grid[rowIndex, colIndex].domainCount--;
                    }
                }
            }
        }
        else
        {
            // Go through the remaining tiles of the last cell domain
            for (int i = 0; i < lastCell.domain.Length; i++)
            {
                if (lastCell.domain[i])
                {
                    for (int j = 0; j < grid[rowIndex, colIndex].domain.Length; j++)
                    {
                        if (grid[rowIndex, colIndex].domain[j])
                        {
                            // Check which tiles from the current domain respects the constraints determined by the last cell tiles
                            if ((direction == 0 && tileSet[j].tile.sideIndex[2] == tileSet[i].tile.sideIndex[direction])
                            || (direction == 1 && tileSet[j].tile.sideIndex[3] == tileSet[i].tile.sideIndex[direction])
                            || (direction == 2 && tileSet[j].tile.sideIndex[0] == tileSet[i].tile.sideIndex[direction])
                            || (direction == 3 && tileSet[j].tile.sideIndex[1] == tileSet[i].tile.sideIndex[direction]))
                            {
                                grid[rowIndex, colIndex].visited[j]++;
                            }

                        }
                    }
                }
            }

            // Remove the tiles that don't respect the constrain from the current cell domain
            for (int i = 0; i < grid[rowIndex, colIndex].visited.Length; i++)
            {
                if (grid[rowIndex, colIndex].domain[i] && grid[rowIndex, colIndex].visited[i] < 1) {
                    grid[rowIndex, colIndex].domain[i] = false;
                    grid[rowIndex, colIndex].domainCount--;
                }
                else
                    grid[rowIndex, colIndex].visited[i] = 0;
            }
        }

        if(grid[rowIndex, colIndex].domainCount == 1)
        {
            int chosenIndex = -1;
            for (int i = 0; i < grid[rowIndex, colIndex].domain.Length; i++)
            {
                if (grid[rowIndex, colIndex].domain[i])
                {
                    chosenIndex = i;
                    break;
                }     
            }

            InstantiateTile(rowIndex, colIndex, chosenIndex);
        }

        //Calculate entropy after the constraint propagation
        grid[rowIndex, colIndex].CalculateEntropy(tileSet);

        // Propagates the constraints bearing in mind the current tile
        if (colIndex > 0 && direction != 1)
            ConstraintPropagation(rowIndex, colIndex - 1, 3, grid[rowIndex, colIndex], step);
        if (colIndex < (numCol - 1) && direction != 3)
            ConstraintPropagation(rowIndex, colIndex + 1, 1, grid[rowIndex, colIndex], step);
        if (rowIndex > 0 && direction != 0)
            ConstraintPropagation(rowIndex - 1, colIndex, 2, grid[rowIndex, colIndex], step);
        if (rowIndex < (numRow - 1) && direction != 2)
            ConstraintPropagation(rowIndex + 1, colIndex, 0, grid[rowIndex, colIndex], step);
    }

    /// <summary>
    /// Method that chooses randomly a tile from the remaining tiles of the domain biased by their weights
    /// </summary>
    /// <param name="availableTiles">Tiles that still are available in the domain</param>
    /// <returns></returns>
    private int weightedRandom(Tile[] availableTiles) {
        int max = availableTiles[0].weight;

        for( int k = 1; k < availableTiles.Length; k++)
        {
            max += availableTiles[k].weight;
        }

        int target = Mathf.RoundToInt(UnityEngine.Random.Range(0, max));
        int choosenNumber = 0;
        while(target > availableTiles[choosenNumber].weight && choosenNumber < availableTiles.Length)
        {
            target -= availableTiles[choosenNumber].weight;
            choosenNumber++;
        }

        for( int k = 0; k < tileSet.Count; k++)
        {
            if (availableTiles[choosenNumber].tile.name == tileSet[k].tile.name)
            {
                choosenNumber = k;
                break;
            }
        }

        return choosenNumber;
    }

    /// <summary>
    /// Make the tile map grid observable in the editor
    /// </summary>
    private void OnDrawGizmos()
    {
        // Draw Grid Edges
        Gizmos.DrawLine(transform.position, new Vector3(numCol + transform.position.x, transform.position.y, transform.position.z));
        Gizmos.DrawLine(transform.position, new Vector3(transform.position.x, transform.position.y, transform.position.z + numRow));
        Gizmos.DrawLine(new Vector3(transform.position.x, transform.position.y, transform.position.z + numRow), new Vector3(transform.position.x + numCol, transform.position.y, transform.position.z + numRow));
        Gizmos.DrawLine(new Vector3(transform.position.x + numCol, transform.position.y, transform.position.z), new Vector3(transform.position.x + numCol, transform.position.y, transform.position.z + numRow));

        // Draw Grid
        for (int i = 0; i < numCol; i++)
        {
            Gizmos.DrawLine(new Vector3(transform.position.x + i * tileSize.x, transform.position.y, transform.position.z), new Vector3(transform.position.x + i * tileSize.x, transform.position.y, transform.position.z + numRow));
        }

        for (int i = 0; i < numRow; i++)
        {
            Gizmos.DrawLine(new Vector3(transform.position.x, transform.position.y, transform.position.z + i * tileSize.x), new Vector3(transform.position.x + numCol, transform.position.y, transform.position.z + i * tileSize.x));
        }
    }
}
